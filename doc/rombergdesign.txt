求romberg龙贝格定积分值的程序开发过程
第一部分：缘由
前几天见到亲戚的某个作业，要求编写计算romberg的程序。交流后想着自己写一下程序，并记录下来思考和设计过程，做为一个例子，可供学程序设计的高中和大学生借鉴。
编程序和写文档用了一天的时间。本程序是用C语言设计的，如果用lua等脚本语言编的会更快些。

第二部分：计算方法
romberg的计算方法参考自网页《龙贝格求积法》：
https://wenku.baidu.com/view/6350c4fbf18583d048645954
详见附下图。

第三部分：程序设计过程
一、明确问题的给定条件和解决结果，以及其它存储和用时要求
根据romberg定积分计算方法，给定a,b,f(x)，算出T, S, C, R序列，求最终的R值。
输入：a,b,f(x);
输出：Rn
中间数据结构：T, S, C, R序列。

二、关键数据结构设计
1、关键数据结构的类型设计
romberg的关键数据结构是T, S, C, R序列。序列应设计成数组，这样编程容易且满足本需求。每个序列1个数组就是4个数组。有2个关键：
A、序列的数值怎么填到数组中。是按T0,T1,T2,T4逐个放入数组T[0],T[1],T[2],T[3]中，还是按脚标放入数组T[0],T[1],T[2],T[4]中；C1是放入数组C[0]中，还是放入C[2]中。
经考虑，T逐个放入数组中较合理，按脚标放入数组占用空间大；
C1从C[2]还是C[0]开始待设计函数时再决定。
B、序列的长度。
因从T到R长度是逐步减1的，所以整体序列的长度可定为T或R的长度。

2、关键数据结构的实现方式
序列可用动态数组或普通数组实现。
用动态数组如vector等，好处是不用操心数组长度增加时多申请内存、长度减少时释放内存等，不容易出现内存溢出或泄漏方面的问题；用普通数组，好处是效率高，不好处是长度编程时事先的固定。
经分析用普通定长数组，因为计算过程中用到2的整次幂，而长整数是64位二进制长度的，所以将最大长度设计为64是可行且合理的。

三、算法设计
1、第一直觉
根据计算公式，先算出T，再算S，再算C，再算R。所以第一反应是先算出64个T，再算63个S、62个C、61个R。
但这样不能根据给定的最小误差来计算，比如说根据给出的最小误差实际上算到R3就可以了，但还是要算到R[61]，这样造成运算能力的浪费，而且程序执行时间变长。所以这种思路暂不考虑。

2、模拟并分析计算过程
经过分析计算公式，T0直接计算出来，根据T0算出T1，用[T0]=>T1表示。则
[a,b,f(x)]=>T0,
[T0]=>T1, [T0,T1]=>S1,
[T1]=>T2, [T1,T2]=>S2, [S1,S2]=>C1,
[T2]=>T4, [T2,T4]=>S4, [S2,S4]=>C2, [C1,C2]=>R1
[T4]=>T8, [T4,T8]=>S8, [S4,S8]=>C4, [C2,C4]=>R2
[T8]=>T16, [T8,T16]=>S16, [S8,S16]=>C8, [C4,C8]=>R16
经仔细观察，从R2开始，后面的计算Rn时参与运算的序列个数是不变的；R2之前，每一行的运算的序列个数都有变化是递增的。所以可以把前4行直到计算R1为止，做为一个整体来实现。
从R2开始，每一行的计算都是根据上一行的结果算出来的。所以要计算到第n行，则先把前4步算出来，然后逐行计算，直到第n行为止。

3、主要函数设计
根据第2步分析，可以设计3个主要函数，分别是：计算前4行；计算已算出来的行的下一行；按要求计算出来全部的序列。

4、辅助函数设计
根据需要再增加些数据初始化、打印等函数。
并根据设计思路，设计测试函数。

四、程序设计
1、根据前面的分析设计，关键数据结构有：
输入求积分的a,b,f(x);
序列数组：T[], S[], C[], R[], 序列数组长度：count, 序列数组最大长度预设为64。
为便于设计和计算，将误差也做为序列数组的1种，delta[], delta[i]=R[i]-R[i-1]，delta[3]=R[3]-C[3];

2、主要函数设计
上述2个数据结构的初始化、打印显示。
计算序列数组。可按T的数量来计算，也可按是否满足最小误差来计算。

五、编程调试
输入源代码，编译除错调试除错，优化重构。编程时必然会犯低级错误，调试时要有耐心。本次编程调试用时较多的除错有3处。

1、错误1
错误的：if (i = 0)，
错误原因：执行时死循环没反应，看了十来分钟源代码发现这里错，少打了个=号，
正确的：if(i == 0)

2、错误2
错误的：rset->T[i] = (in->b - in->a) / 2 * (in->f(in->b) - in->f(in->a));
错误原因：执行时测试数据的输出结果始终和正确结果对不上，找了二十来分钟才发现是眼花了公式没打对，打成f(b)-f(a)，正确的应该是f(b)+f(a)。
正确的：rset->T[i] = (in->b - in->a) / 2 * (in->f(in->b) + in->f(in->a));

3、错误3
错误的：while (rset->delta[i] > mindelta)
错误原因：rset->delta[i]值可能是正的也可能是负的，而mindelta是个为正的常数。判断误差的本意是绝对值比最小误差大或小，而这里没加绝对值，看了十来分钟才明白错在哪儿。
正确的：while (fabs(rset->delta[i]) > mindelta)

六、关键点
1、明确问题，输入什么，输出什么，有什么时间、容量限制等。
2、搞懂解决问题的方法，通过哪些公式、哪些步骤来编程。
3、一定要先设计再编代码。磨刀不误砍柴工，不设计就写代码非常低效费时，程序也乱七八糟不好调试。
4、写完代码不要急着编译，仔细读一读代码，尽量多的找出来问题并改正。
4、编译、调试、测试时要耐心。
5、要重构，使代码更合理更精炼。
6、再具体内容详见源代码及其中的注释。
7、要写好测试函数。